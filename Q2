module SIMPLE-TYPED-DYNAMIC-EXCEPTIONS-PROPAGATION
  imports SIMPLE-TYPED-DYNAMIC // from your provided code

  // We override the exception handling rules here to allow propagation

  syntax KItem ::= (Param,Stmt,K,Map,ControlCellFragment)
  syntax KItem ::= "popx"

  // Original rule:
  // rule <k> (try S1 catch(P) S2 => S1 ~> popx) ~> K </k>
  //       <control>
  //         <xstack> .List => ListItem((P, S2, K, Env, C)) ...</xstack>
  //         C
  //       </control>
  //       <env> Env </env>

  rule <k> (try S1 catch(P) S2 => S1 ~> popx) ~> K </k>
       <control>
         <xstack> .List => ListItem((P:Param, S2, K, Env, C)) ...</xstack>
         C
       </control>
       <env> Env </env>

  rule <k> popx => .K ...</k>
       <xstack> ListItem(_) => .List ...</xstack>

  // Modified throw rule:
  // If type matches, handle exception:
  rule <k> throw V:Val; ~> _ => { T X = V; S2 } ~> K </k>
       <control>
         <xstack> ListItem((T:Type X:Id, S2, K, Env, C)) => .List ...</xstack>
         (_ => C)
       </control>
       <env> _ => Env </env>
    requires typeOf(V) ==K T

  // If type does NOT match, pop the current handler and re-throw:
  rule <k> throw V:Val; => throw V; ...</k>
       <control>
         <xstack> ListItem((T:Type _, _, _, _, _)) => XS </xstack>
       </control>
    requires notBool(typeOf(V) ==K T)

  // If no handlers match and no handlers left:
  // If we run out of xstack items while re-throwing, stuck:
  rule <k> throw V:Val; => .K ...</k>
       <control> <xstack> .List </xstack> </control>
    [owise] // gets stuck

endmodule
